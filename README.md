# FIBONACCI SEQUENCE CHALLENGE RULES (WIP)

# Goal:
**Calculating** and **Printing** the fibonacci sequence 
# Rules:
- Any **High Level** compiled language (c/c++/rust/go...) that compiles to **Low Level** assembly
- No cheating by using predefined fibonacci funcions in libraries (math.fib(), fibonacci(), fib()...)
- Code must run on the CPU
- no (weird tricks/CUDA/offloading (to Bitcoin), etc...)
- the function must return type must be **long long int** or any other integer type with same size 
- no custom libraries
- no copying from the internet
- using only the standard library
- no device drivers 
- compiler precalculations 
- **multiprocessing** is not allowed
- no pure hardware

# Allowed:
- You can use the satandard libary of Any **High Level** compiled language (c/c++/rust/go...) Excluding predefined fibonacci funcions
- Any CPU based features such as **threading** or any other type of **pararelism**

# Evaluation:
- runtime speed 50%
- algorithmic complexity (for inputs p and q, how many operations does it take) (big O notation) 50%

# Judgement
- Oscar must be neutral and objective
- Participants can not talk to Oscar about the competition without the presence of the other participants
- Oscar can only be replaced as a judge if 2 of the participants agree

# Contextual Definitions:
- **Calculating:** Getting the numbers of the fibonacci sequence through a mathematical algorithm
- **Printing:** Writing the numbers of the fibonacci sequence to: The terminal, a file or a gui
- **High Level:** Languages that abstract low level assembly with variables, loops, control flow, functions...
- **Low Level:** Assembly language that can be directly converted to machine code. This excludes (Java Bytecode, C# IL assembly, Python pycache, WASM...)
- **long long int:** A 64bit integer
- **multiprocessing:** The act of spliting the workforce between different processes to improve runtime performance 
- **threading:** Runing a function in a **thread**
- **thread:** A lightweight program that is emmited by another program in the same process, often used to split and optimize de workforce
- **paralelism:** Running code from the same program at the same time 
- **Ã“scar:** Is a living entity in charge of evaluating the code, and giving a final veredict in the competition
